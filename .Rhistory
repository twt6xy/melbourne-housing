library(lubridate)
melbourne <- read.csv("melb_data_raw.csv", header=TRUE)
# We don't need method, seller, or address.
melbourne <- subset(melbourne, select = -c(Address, SellerG, Method))
# list of categorical variables
cats <- c('Type', 'Regionname', 'Postcode', 'CouncilArea', 'Suburb')
# tell R that categorical variables are a factor
melbourne[,cats] <- lapply(melbourne[,cats], factor)
mdy <- mdy(melbourne$Date)
dmy <- dmy(melbourne$Date)
mdy[is.na(mdy)] <- dmy[is.na(mdy)]
melbourne$Date <- mdy
melbourne <- read.csv("melb_data_raw.csv", header=TRUE)
# We don't need method, seller, or address.
melbourne <- subset(melbourne, select = -c(Address, SellerG, Method))
# list of categorical variables
cats <- c('Type', 'Regionname', 'Postcode', 'CouncilArea', 'Suburb')
# tell R that categorical variables are a factor
melbourne[,cats] <- lapply(melbourne[,cats], factor)
# ===============================================================================
# There are multiple date formats in the date column {17/09/2016, 4/03/2017, etc.}
# We can standardize the date formatting with the lubridate package
# ===============================================================================
mdy <- mdy(melbourne$Date)
dmy <- dmy(melbourne$Date)
mdy[is.na(mdy)] <- dmy[is.na(mdy)]
melbourne$Date <- mdy
colSums(is.na(melbourne))
melbourne <- melbourne[!is.na(melbourne$Car),]
colSums(is.na(melbourne))
melbourne <- read.csv("melb_data_raw.csv", header=TRUE)
# We don't need method, seller, or address.
melbourne <- subset(melbourne, select = -c(Address, SellerG, Method))
# list of categorical variables
cats <- c('Type', 'Regionname', 'Postcode', 'CouncilArea', 'Suburb')
# tell R that categorical variables are a factor
melbourne[,cats] <- lapply(melbourne[,cats], factor)
mdy <- mdy(melbourne$Date)
dmy <- dmy(melbourne$Date)
mdy[is.na(mdy)] <- dmy[is.na(mdy)]
melbourne$Date <- mdy
medianPricesBySuburb <- summarise(suburbGroups, medianPrice=median(Price, na.rm=TRUE))
suburbGroups <- group_by(melbourne, melbourne$Suburb)
medianPricesBySuburb <- summarise(suburbGroups, medianPrice=median(Price, na.rm=TRUE))
View(medianPricesBySuburb)
medianBuildingAreaBySuburb <- summarise(suburbGroups, medianBuildingArea=median(BuildingArea, na.rm=TRUE))
medianYearBuiltBySuburb <- summarise(suburbGroups, medianYearBuilt=median(YearBuilt, na.rm=TRUE))
View(medianYearBuiltBySuburb)
View(medianBuildingAreaBySuburb)
suburbCounts <- table(melbourne$Suburb)
suburbCounts
bedRoomCounts <- table(melbourne$Bedroom2)
bedRoomCounts
View(suburbGroups)
medianBuildingAreaByNumBedrooms <- summarise(melbourne$Bedroom2, medianBuildingArea=median(BuildingArea, na.rm=TRUE))
medianBuildingAreaByNumBedrooms <- summarise(bedroomGroups, medianBuildingArea=median(BuildingArea, na.rm=TRUE))
bedroomGroups <- group_by(melbourne, melbourne$Bedroom2)
medianBuildingAreaByNumBedrooms <- summarise(bedroomGroups, medianBuildingArea=median(BuildingArea, na.rm=TRUE))
melbourne <- read.csv("melb_data_raw.csv", header=TRUE)
cats <- c('Type', 'Regionname', 'Postcode', 'CouncilArea', 'Suburb')
melbourne[,cats] <- lapply(melbourne[,cats], factor)
mdy <- mdy(melbourne$Date)
dmy <- dmy(melbourne$Date)
mdy[is.na(mdy)] <- dmy[is.na(mdy)]
melbourne$Date <- mdy
bedRoomCounts <- table(melbourne$Bedroom2)
bedroomGroups <- group_by(melbourne, melbourne$Bedroom2)
medianBuildingAreaByNumBedrooms <- summarise(bedroomGroups, medianBuildingArea=median(BuildingArea, na.rm=TRUE))
melbourne <- read.csv("melb_data_raw.csv", header=TRUE)
# We don't need method, seller, or address.
#melbourne <- subset(melbourne, select = -c(Address, SellerG, Method))
# ==============================================================================
# The dataset contains multiple categorical variables, so create a list of them
# and tell R to turn them into a factor
# ==============================================================================
cats <- c('Type', 'Regionname', 'Postcode', 'CouncilArea', 'Suburb')
melbourne[,cats] <- lapply(melbourne[,cats], factor)
# ===============================================================================
# There are multiple date formats in the date column {17/09/2016, 4/03/2017, etc.}
# We can standardize the date formatting with the lubridate package
# ===============================================================================
mdy <- mdy(melbourne$Date)
dmy <- dmy(melbourne$Date)
mdy[is.na(mdy)] <- dmy[is.na(mdy)]
melbourne$Date <- mdy
bedroomGroups <- group_by(melbourne, melbourne$Bedroom2)
medianBuildingAreaByNumBedrooms <- summarise(bedroomGroups, medianBuildingArea=median(BuildingArea, na.rm=TRUE))
View(medianBuildingAreaByNumBedrooms)
bedRoomCounts <- table(melbourne$Bedroom2)
bedRoomCounts
bedRoomAndTypeGrouped <- melbourne %>% group_by(Bedroom2, Type)
View(bedRoomAndTypeGrouped)
bedroomGroups <- group_by(bedRoomAndTypeGrouped, melbourne$Bedroom2)
bedRoomAndTypeGrouped <- melbourne %>%
group_by(Bedroom2, Type) %>%
summarise(medianArea = median(BuildingArea))
View(bedRoomAndTypeGrouped)
bedRoomAndTypeGrouped <- melbourne %>%
group_by(Bedroom2, Type) %>%
summarise(medianArea = median(BuildingArea, na.rm=TRUE))
View(bedRoomAndTypeGrouped)
bedRoomAndTypeGrouped <- melbourne %>%
group_by(Bedroom2, Type) %>%
summarise(medianArea = mean(BuildingArea, na.rm=TRUE))
View(bedRoomAndTypeGrouped)
bedRoomAndTypeGrouped <- melbourne %>%
group_by(Bedroom2, Type) %>%
summarise(medianArea = median(BuildingArea, na.rm=TRUE))
View(bedRoomAndTypeGrouped)
melbourne <- read.csv("melb_data_raw.csv", header=TRUE)
# We don't need method, seller, or address.
#melbourne <- subset(melbourne, select = -c(Address, SellerG, Method))
# ==============================================================================
# The dataset contains multiple categorical variables, so create a list of them
# and tell R to turn them into a factor
# ==============================================================================
cats <- c('Type', 'Regionname', 'Postcode', 'CouncilArea', 'Suburb')
melbourne[,cats] <- lapply(melbourne[,cats], factor)
# ===============================================================================
# There are multiple date formats in the date column {17/09/2016, 4/03/2017, etc.}
# We can standardize the date formatting with the lubridate package
# ===============================================================================
mdy <- mdy(melbourne$Date)
dmy <- dmy(melbourne$Date)
mdy[is.na(mdy)] <- dmy[is.na(mdy)]
melbourne$Date <- mdy
# Checking for null columns
#colSums(is.na(melbourne))
# ===========================================================================================================
# BuildingArea: 6417 NA Values - fillna with median building area for houses type with same number of bedrooms
# YearBuilt: 5344 NA Values - fillna with the median year built in the respective suburb
# Car: 62 NA Values - fillna with with mode of Car since it's only 62 instances
# ============================================================================================================
bedRoomAndTypeGrouped <- melbourne %>%
group_by(Bedroom2, Type) %>%
summarise(medianArea = median(BuildingArea, na.rm=TRUE))
suburbAndTypeGrouped <- melbourne %>%
group_by(Suburb, Type) %>%
summarise(medianYear = median(YearBuilt, na.rm=TRUE))
View(suburbAndTypeGrouped)
View(melbourne)
View(bedRoomAndTypeGrouped)
View(suburbAndTypeGrouped)
View(melbourne)
vals <- c("Gut", "Data", "Science", "Phil")
intm <- dd[-1]==1 & !is.na(dd[-1])
testMerge <- merge(melbourne, bedRoomAndTypeGrouped)
View(testMerge)
View(melbourne)
melbourne <- read.csv("melb_data_raw.csv", header=TRUE)
# We don't need method, seller, or address.
#melbourne <- subset(melbourne, select = -c(Address, SellerG, Method))
# ==============================================================================
# The dataset contains multiple categorical variables, so create a list of them
# and tell R to turn them into a factor
# ==============================================================================
cats <- c('Type', 'Regionname', 'Postcode', 'CouncilArea', 'Suburb')
melbourne[,cats] <- lapply(melbourne[,cats], factor)
# ===============================================================================
# There are multiple date formats in the date column {17/09/2016, 4/03/2017, etc.}
# We can standardize the date formatting with the lubridate package
# ===============================================================================
mdy <- mdy(melbourne$Date)
dmy <- dmy(melbourne$Date)
mdy[is.na(mdy)] <- dmy[is.na(mdy)]
melbourne$Date <- mdy
# Checking for null columns
#colSums(is.na(melbourne))
# =================================================================================================================
# BuildingArea: 6417 NA Values - fillna with median building area for type of building with same number of bedrooms
# YearBuilt: 5344 NA Values - fillna with the median year built for type of building in the respective suburb
# REASONING: Filling NA values strictly by suburb or number of bedrooms would introduce flawed assumptions,
#            an old suburb that used to consist of mainly houses may be be home to new builds that would
#            consist of townhomes and apartments, so we need to consider building type during the imputations.
# Car: 62 NA Values - fillna with with mode of Car since it's only 62 instances
# =================================================================================================================
roomsAndTypeGrouped <- melbourne %>%
group_by(Rooms, Type) %>%
summarise(medianArea = median(BuildingArea, na.rm=TRUE))
View(roomsAndTypeGrouped)
suburbAndTypeGrouped <- melbourne %>%
group_by(Suburb, Type) %>%
summarise(medianYear = median(YearBuilt, na.rm=TRUE))
testMerge <- merge(melbourne, roomsAndTypeGrouped)
melbourne$Address["199 Moor St"]
melbourne[melbourne$Address=="199 Moor St"]
testMerge <- testMerge[order(Suburb),]
testMerge <- testMerge[order(testMerge$Suburb),]
testMerge$BuildingArea <- ifelse(is.na(testMerge$BuildingArea), testMerge$medianArea)
testMerge$BuildingArea <- ifelse(is.na(testMerge$BuildingArea), testMerge$medianArea, testMerge$BuildingArea)
View(roomsAndTypeGrouped)
testMerge <- merge(testMerge, suburbAndTypeGrouped)
testMerge$BuildingArea <- ifelse(is.na(testMerge$YearBuilt), testMerge$medianYear, testMerge$YearBuilt)
View(suburbAndTypeGrouped)
melbourne <- read.csv("melb_data_raw.csv", header=TRUE)
# We don't need method, seller, or address.
#melbourne <- subset(melbourne, select = -c(Address, SellerG, Method))
# ==============================================================================
# The dataset contains multiple categorical variables, so create a list of them
# and tell R to turn them into a factor
# ==============================================================================
cats <- c('Type', 'Regionname', 'Postcode', 'CouncilArea', 'Suburb')
melbourne[,cats] <- lapply(melbourne[,cats], factor)
# ===============================================================================
# There are multiple date formats in the date column {17/09/2016, 4/03/2017, etc.}
# We can standardize the date formatting with the lubridate package
# ===============================================================================
mdy <- mdy(melbourne$Date)
dmy <- dmy(melbourne$Date)
mdy[is.na(mdy)] <- dmy[is.na(mdy)]
melbourne$Date <- mdy
# Checking for null columns
#colSums(is.na(melbourne))
# =================================================================================================================
# BuildingArea: 6417 NA Values - fillna with median building area for type of building with same number of bedrooms
# YearBuilt: 5344 NA Values - fillna with the median year built for type of building in the respective suburb
# REASONING: Filling NA values strictly by suburb or number of bedrooms would introduce flawed assumptions,
#            an old suburb that used to consist of mainly houses may be be home to new builds that would
#            consist of townhomes and apartments, so we need to consider building type during the imputations.
# Car: 62 NA Values - fillna with with mode of Car since it's only 62 instances
# =================================================================================================================
roomsAndTypeGrouped <- melbourne %>%
group_by(Rooms, Type) %>%
summarise(medianArea = median(BuildingArea, na.rm=TRUE))
suburbAndTypeGrouped <- melbourne %>%
group_by(Suburb, Type) %>%
summarise(medianYear = median(YearBuilt, na.rm=TRUE))
testMerge <- merge(melbourne, roomsAndTypeGrouped)
testMerge$BuildingArea <- ifelse(is.na(testMerge$BuildingArea), testMerge$medianArea, testMerge$BuildingArea)
testMerge <- merge(testMerge, suburbAndTypeGrouped)
testMerge$YearBuilt <- ifelse(is.na(testMerge$YearBuilt), testMerge$medianYear, testMerge$YearBuilt)
colSums(is.na(testMerge))
melbourne <- read.csv("melb_data_raw.csv", header=TRUE)
# We don't need method, seller, or address.
#melbourne <- subset(melbourne, select = -c(Address, SellerG, Method))
# ==============================================================================
# The dataset contains multiple categorical variables, so create a list of them
# and tell R to turn them into a factor
# ==============================================================================
cats <- c('Type', 'Regionname', 'Postcode', 'CouncilArea', 'Suburb')
melbourne[,cats] <- lapply(melbourne[,cats], factor)
# ===============================================================================
# There are multiple date formats in the date column {17/09/2016, 4/03/2017, etc.}
# We can standardize the date formatting with the lubridate package
# ===============================================================================
mdy <- mdy(melbourne$Date)
dmy <- dmy(melbourne$Date)
mdy[is.na(mdy)] <- dmy[is.na(mdy)]
melbourne$Date <- mdy
# Checking for null columns
#colSums(is.na(melbourne))
# =================================================================================================================
# BuildingArea: 6417 NA Values - fillna with median building area for type of building with same number of bedrooms
# YearBuilt: 5344 NA Values - fillna with the median year built for type of building in the respective suburb
# REASONING: Filling NA values strictly by suburb or number of bedrooms would introduce flawed assumptions,
#            an old suburb that used to consist of mainly houses may be be home to new builds that would
#            consist of townhomes and apartments, so we need to consider building type during the imputations.
# Car: 62 NA Values - fillna with with mode of Car since it's only 62 instances
# =================================================================================================================
roomsAndTypeGrouped <- melbourne %>%
group_by(Rooms, Type) %>%
summarise(medianArea = median(BuildingArea, na.rm=TRUE))
suburbAndTypeGrouped <- melbourne %>%
group_by(Suburb, Type) %>%
summarise(medianYear = median(YearBuilt, na.rm=TRUE))
testMerge <- merge(melbourne, roomsAndTypeGrouped, by=c("Rooms", "Type"))
testMerge$BuildingArea <- ifelse(is.na(testMerge$BuildingArea), testMerge$medianArea, testMerge$BuildingArea)
testMerge <- merge(testMerge, suburbAndTypeGrouped, by=c("Suburb", "Type"))
testMerge$YearBuilt <- ifelse(is.na(testMerge$YearBuilt), testMerge$medianYear, testMerge$YearBuilt)
roomsAndTypeGrouped$medianArea[3]
melbourne <- read.csv("melb_data_raw.csv", header=TRUE)
# We don't need method, seller, or address.
#melbourne <- subset(melbourne, select = -c(Address, SellerG, Method))
# ==============================================================================
# The dataset contains multiple categorical variables, so create a list of them
# and tell R to turn them into a factor
# ==============================================================================
cats <- c('Type', 'Regionname', 'Postcode', 'CouncilArea', 'Suburb')
melbourne[,cats] <- lapply(melbourne[,cats], factor)
# ===============================================================================
# There are multiple date formats in the date column {17/09/2016, 4/03/2017, etc.}
# We can standardize the date formatting with the lubridate package
# ===============================================================================
mdy <- mdy(melbourne$Date)
dmy <- dmy(melbourne$Date)
mdy[is.na(mdy)] <- dmy[is.na(mdy)]
melbourne$Date <- mdy
# Checking for null columns
#colSums(is.na(melbourne))
# =================================================================================================================
# BuildingArea: 6417 NA Values - fillna with median building area for type of building with same number of bedrooms
# YearBuilt: 5344 NA Values - fillna with the median year built for type of building in the respective suburb
# REASONING: Filling NA values strictly by suburb or number of bedrooms would introduce flawed assumptions,
#            an old suburb that used to consist of mainly houses may be be home to new builds that would
#            consist of townhomes and apartments, so we need to consider building type during the imputations.
# Car: 62 NA Values - fillna with with mode of Car since it's only 62 instances
# =================================================================================================================
roomsAndTypeGrouped <- melbourne %>%
group_by(Rooms, Type) %>%
summarise(medianArea = median(BuildingArea, na.rm=TRUE))
suburbAndTypeGrouped <- melbourne %>%
group_by(Suburb, Type) %>%
summarise(medianYear = median(YearBuilt, na.rm=TRUE))
# =======================================================================================================
# median for 4 rooms of type U = 171.5, so I'm going to double it for the null value at 8 rooms of type u.
# median for 5 rooms of type h = 260, so I'm doubling it for the null value at 10 rooms of type h
# =======================================================================================================
roomsAndTypeGrouped$medianArea[19]=394.45
roomsAndTypeGrouped$medianArea[20]=520
# =====================================================
# Performing the merges on a copy of the melbourne data
# =====================================================
testMerge <- merge(melbourne, roomsAndTypeGrouped, by=c("Rooms", "Type"))
testMerge$BuildingArea <- ifelse(is.na(testMerge$BuildingArea), testMerge$medianArea, testMerge$BuildingArea)
testMerge <- merge(testMerge, suburbAndTypeGrouped, by=c("Suburb", "Type"))
testMerge$YearBuilt <- ifelse(is.na(testMerge$YearBuilt), testMerge$medianYear, testMerge$YearBuilt)
colSums(is.na(testMerge))
CarAndTypeGrouped <- melbourne %>%
group_by(Car, Type) %>%
summarise(medianCar = median(Car, na.rm=TRUE))
View(CarAndTypeGrouped)
TypeGrouped <- melbourne %>%
group_by(Type) %>%
summarise(medianCar = median(Car, na.rm=TRUE))
View(TypeGrouped)
testMerge <- merge(testMerge, TypeGrouped, by="Type")
testMerge$Car <- ifelse(is.na(testMerge$Car), testMerge$medianCar, testMerge$Car)
colSums(is.na(testMerge))
TypeGroupForRemainingNAyears <- melbourne %>%
group_by(Type) %>%
summarise(medianYearType = median(YearBuilt, na.rm=TRUE))
View(TypeGroupForRemainingNAyears)
testMerge <- merge(testMerge, TypeGroupForRemainingNAyears, by="Type")
testMerge$YearBuilt <- ifelse(is.na(testMerge$YearBuilt), testMerge$medianYearType, testMerge$YearBuilt)
colSums(is.na(testMerge))
colSums(is.na(testMerge))
View(melbourne)
testMerge <- subset(testMerge, select = -c(medianArea, medianYear, medianCar, medianYearType))
melbourne <- read.csv("melb_data_raw.csv", header=TRUE)
# We don't need method, seller, or address.
#melbourne <- subset(melbourne, select = -c(Address, SellerG, Method))
# ==============================================================================
# The dataset contains multiple categorical variables, so create a list of them
# and tell R to turn them into a factor
# ==============================================================================
cats <- c('Type', 'Regionname', 'Postcode', 'CouncilArea', 'Suburb')
melbourne[,cats] <- lapply(melbourne[,cats], factor)
# ===============================================================================
# There are multiple date formats in the date column {17/09/2016, 4/03/2017, etc.}
# We can standardize the date formatting with the lubridate package
# ===============================================================================
mdy <- mdy(melbourne$Date)
dmy <- dmy(melbourne$Date)
mdy[is.na(mdy)] <- dmy[is.na(mdy)]
melbourne$Date <- mdy
# Checking for null columns
#colSums(is.na(melbourne))
# =================================================================================================================
# BuildingArea: 6417 NA Values - fillna with median building area for type of building with same number of bedrooms
# YearBuilt: 5344 NA Values - fillna with the median year built for type of building in the respective suburb
# REASONING: Filling NA values strictly by suburb or number of bedrooms would introduce flawed assumptions,
#            an old suburb that used to consist of mainly houses may be be home to new builds that would
#            consist of townhomes and apartments, so we need to consider building type during the imputations.
# Car: 62 NA Values - fillna with with mode of Car since it's only 62 instances
# =================================================================================================================
# getting the median building area by number of rooms and type of building
roomsAndTypeGrouped <- melbourne %>%
group_by(Rooms, Type) %>%
summarise(medianArea = median(BuildingArea, na.rm=TRUE))
# getting the median year built by suburb and type of building
suburbAndTypeGrouped <- melbourne %>%
group_by(Suburb, Type) %>%
summarise(medianYear = median(YearBuilt, na.rm=TRUE))
# getting the median number of car spots per building type to fill the 62 null values with
TypeGrouped <- melbourne %>%
group_by(Type) %>%
summarise(medianCar = median(Car, na.rm=TRUE))
# After grouping median year built by suburb and type of building, there are still 80 NA values, so I'll fill those by median year by building type
TypeGroupForRemainingNAyears <- melbourne %>%
group_by(Type) %>%
summarise(medianYearType = median(YearBuilt, na.rm=TRUE))
# median for 4 rooms of type U = 171.5, so I'm going to double it for the null value at 8 rooms of type u.
roomsAndTypeGrouped$medianArea[19]=394.45
# median for 5 rooms of type h = 260, so I'm doubling it for the null value at 10 rooms of type h
roomsAndTypeGrouped$medianArea[20]=520
# merging all of the grouped datasets into a copy of the melbourne data, and then filling null values with its respective median value
testMerge <- merge(melbourne, roomsAndTypeGrouped, by=c("Rooms", "Type"))
testMerge$BuildingArea <- ifelse(is.na(testMerge$BuildingArea), testMerge$medianArea, testMerge$BuildingArea)
testMerge <- merge(testMerge, suburbAndTypeGrouped, by=c("Suburb", "Type"))
testMerge$YearBuilt <- ifelse(is.na(testMerge$YearBuilt), testMerge$medianYear, testMerge$YearBuilt)
testMerge <- merge(testMerge, TypeGrouped, by="Type")
testMerge$Car <- ifelse(is.na(testMerge$Car), testMerge$medianCar, testMerge$Car)
testMerge <- merge(testMerge, TypeGroupForRemainingNAyears, by="Type")
testMerge$YearBuilt <- ifelse(is.na(testMerge$YearBuilt), testMerge$medianYearType, testMerge$YearBuilt)
# drop the median columns
testMerge <- subset(testMerge, select = -c(Address, SellerG, Method, medianArea, medianYear, medianCar, medianYearType))
View(testMerge)
# view if any null columns
colSums(is.na(testMerge))
unique(testMerge$CouncilArea)
unique(melbourne$CouncilArea)
write.csv(testMerge, "melbourne_cleaned.csv")
write.csv(testMerge, "./melbourne_cleaned.csv")
write.csv(testMerge, file="./melbourne_cleaned.csv")
write.csv(testMerge, file="./melbourne_cleaned.csv")
suburbAndCouncilGrouped <- melbourne %>%
group_by(Suburb, CouncilArea)
View(suburbAndCouncilGrouped)
melbourne_clean <- read.csv("melbourne_cleaned.csv", header=TRUE)
View(melbourne_clean)
colSums(is.na(melbourne_clean))
# read in the raw data
melbourne <- read.csv("melb_data_raw.csv", header=TRUE)
colSums(is.na(melbourne))
# getting the median building area by number of rooms and type of building
roomsAndTypeGrouped <- melbourne %>%
group_by(Rooms, Type) %>%
summarise(medianArea = median(BuildingArea, na.rm=TRUE))
# getting the median year built by suburb and type of building
suburbAndTypeGrouped <- melbourne %>%
group_by(Suburb, Type) %>%
summarise(medianYear = median(YearBuilt, na.rm=TRUE))
# getting the median number of car spots per building type to fill the 62 null values with
TypeGrouped <- melbourne %>%
group_by(Type) %>%
summarise(medianCar = median(Car, na.rm=TRUE))
# After grouping median year built by suburb and type of building, there are still 80 NA values, so I'll fill those by median year by building type
TypeGroupForRemainingNAyears <- melbourne %>%
group_by(Type) %>%
summarise(medianYearType = median(YearBuilt, na.rm=TRUE))
# filling in the blank council areas
suburbAndCouncilGrouped <- melbourne %>%
group_by(Suburb, CouncilArea)
# median for 4 rooms of type U = 171.5, so I'm going to double it for the null value at 8 rooms of type u.
roomsAndTypeGrouped$medianArea[19]=394.45
# median for 5 rooms of type h = 260, so I'm doubling it for the null value at 10 rooms of type h
roomsAndTypeGrouped$medianArea[20]=520
# merging all of the grouped datasets into a copy of the melbourne data, and then filling null values with its respective median value
testMerge <- merge(melbourne, roomsAndTypeGrouped, by=c("Rooms", "Type"))
testMerge$BuildingArea <- ifelse(is.na(testMerge$BuildingArea), testMerge$medianArea, testMerge$BuildingArea)
testMerge <- merge(testMerge, suburbAndTypeGrouped, by=c("Suburb", "Type"))
testMerge$YearBuilt <- ifelse(is.na(testMerge$YearBuilt), testMerge$medianYear, testMerge$YearBuilt)
testMerge <- merge(testMerge, TypeGrouped, by="Type")
testMerge$Car <- ifelse(is.na(testMerge$Car), testMerge$medianCar, testMerge$Car)
testMerge <- merge(testMerge, TypeGroupForRemainingNAyears, by="Type")
testMerge$YearBuilt <- ifelse(is.na(testMerge$YearBuilt), testMerge$medianYearType, testMerge$YearBuilt)
# drop the median columns. Address, seller, and method of sale don't have much to do with the value of a house
testMerge <- subset(testMerge, select = -c(Address, SellerG, Method, medianArea, medianYear, medianCar, medianYearType))
# view if any null columns
colSums(is.na(testMerge))
testMerge$CouncilArea <- lapply(testMerge, function(x) {
is.na(levels(x)) <- levels(x) == "NA"
x
})
testMerge$CouncilArea <- lapply(testMerge$CouncilArea, function(x) {
is.na(levels(x)) <- levels(x) == "NA"
x
})
colSums(is.na(testMerge))
# read in the raw data
melbourne <- read.csv("melb_data_raw.csv", header=TRUE)
# view if any null columns
colSums(is.na(melbourne))
# =================================================================================================================
# BuildingArea: 6417 NA Values - fillna with median building area for type of building with same number of bedrooms
# YearBuilt: 5344 NA Values - fillna with the median year built for type of building in the respective suburb
# REASONING: Filling NA values strictly by suburb or number of bedrooms would introduce flawed assumptions,
#            an old suburb that used to consist of mainly houses may be be home to new builds that would
#            consist of townhomes and apartments, so we need to consider building type during the imputations.
# Car: 62 NA Values - fillna with with mode of Car since it's only 62 instances
# =================================================================================================================
# getting the median building area by number of rooms and type of building
roomsAndTypeGrouped <- melbourne %>%
group_by(Rooms, Type) %>%
summarise(medianArea = median(BuildingArea, na.rm=TRUE))
# getting the median year built by suburb and type of building
suburbAndTypeGrouped <- melbourne %>%
group_by(Suburb, Type) %>%
summarise(medianYear = median(YearBuilt, na.rm=TRUE))
# getting the median number of car spots per building type to fill the 62 null values with
TypeGrouped <- melbourne %>%
group_by(Type) %>%
summarise(medianCar = median(Car, na.rm=TRUE))
# After grouping median year built by suburb and type of building, there are still 80 NA values, so I'll fill those by median year by building type
TypeGroupForRemainingNAyears <- melbourne %>%
group_by(Type) %>%
summarise(medianYearType = median(YearBuilt, na.rm=TRUE))
# filling in the blank council areas
suburbAndCouncilGrouped <- melbourne %>%
group_by(Suburb, CouncilArea)
# median for 4 rooms of type U = 171.5, so I'm going to double it for the null value at 8 rooms of type u.
roomsAndTypeGrouped$medianArea[19]=394.45
# median for 5 rooms of type h = 260, so I'm doubling it for the null value at 10 rooms of type h
roomsAndTypeGrouped$medianArea[20]=520
# merging all of the grouped datasets into a copy of the melbourne data, and then filling null values with its respective median value
testMerge <- merge(melbourne, roomsAndTypeGrouped, by=c("Rooms", "Type"))
testMerge$BuildingArea <- ifelse(is.na(testMerge$BuildingArea), testMerge$medianArea, testMerge$BuildingArea)
testMerge <- merge(testMerge, suburbAndTypeGrouped, by=c("Suburb", "Type"))
testMerge$YearBuilt <- ifelse(is.na(testMerge$YearBuilt), testMerge$medianYear, testMerge$YearBuilt)
testMerge <- merge(testMerge, TypeGrouped, by="Type")
testMerge$Car <- ifelse(is.na(testMerge$Car), testMerge$medianCar, testMerge$Car)
testMerge <- merge(testMerge, TypeGroupForRemainingNAyears, by="Type")
testMerge$YearBuilt <- ifelse(is.na(testMerge$YearBuilt), testMerge$medianYearType, testMerge$YearBuilt)
# drop the median columns. Address, seller, and method of sale don't have much to do with the value of a house
testMerge <- subset(testMerge, select = -c(SellerG, Method, medianArea, medianYear, medianCar, medianYearType))
# view if any null columns
colSums(is.na(testMerge))
# export to a cleaned csv file
write.csv(testMerge, file="./melbourne_cleaned.csv")
library(lubridate)
melbourne <- read.csv("melbourne_cleaned.csv", header=TRUE)
View(melbourne)
